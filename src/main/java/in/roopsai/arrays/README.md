# Arrays And Hashing

This package contains solutions to various array-related problems from LeetCode. Each problem is solved with a detailed explanation and efficient approach.

| S.No | Problem Name                | Link to LeetCode                                      | Description                                                                                        | TC     | SC     |
|------|-----------------------------|-------------------------------------------------------|----------------------------------------------------------------------------------------------------|--------|--------|
| 1    | Concatenation of Array      | [LeetCode 1929](https://leetcode.com/problems/concatenation-of-array/) | Create a result array, and copy elements from original into result two times in a single pass loop | O(n)   | O(n)   |
| 2    | Valid Anagram               | [LeetCode 242](https://leetcode.com/problems/valid-anagram/)           | Create a frequency array, For one string keep incrementing the frequency, for the other keep decrementing, if the resultant frequency is zero, then both strings are anagrams | O(n)   | O(1)   |
| 3    | Contains Duplicate          | [LeetCode 217](https://leetcode.com/problems/contains-duplicate/)      | Create a HashSet of seenNumbers, if a number is seen it means a duplicate, else simply add the number to the set. At the completion of loop return false | O(n)   | O(n)   |
| 4    | Two Sum                     | [LeetCode 1](https://leetcode.com/problems/two-sum/)                   | Create a map. In the single pass loop, initially calculate the complement and if the map contains the complement then return two indices of the pair. If not exists, then add the entry (key=number, value=index of the number in array) to the map | O(n)   | O(n)   |
| 5    | Remove Element              | [LeetCode 27](https://leetcode.com/problems/remove-element/)           | Use Two Pointer Approach (i at the start of the array, j at the end of the array). If the nums[i] != val keep incrementing i, else check if nums[j] == val if so decrement j, else simply swap nums[i], nums[j]. do this until both i, j cross each other. | O(n)   | O(1)   |
| 6    | Longest Common Prefix       | [LeetCode 14](https://leetcode.com/problems/longest-common-prefix/)    | Assume first string is the longestCommonPrefix, for the later strings keep check if the prefix string starts at 0, until it will happen keep removing last character of the prefix string. | O(n \* m) | O(1)   |
| 7    | Majority Element            | [LeetCode 169](https://leetcode.com/problems/majority-element/)        | Initialize count to 0, for each number if number is same as majority keep incrementing count, else decrement it. If count equals zero reset majority element to current element. | O(n)   | O(1)   |0,0                                         f5h66